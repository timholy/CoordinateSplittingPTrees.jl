### General utilities

"""
    top, success = chaintop(box)

Return a Box `top` that lies at the top of a chain containing
`box`. If we let `n = ndims(box)` and `p = degree(box)`, a chain has
the property that if one follows `ceil(Int, n/p)` splits downward from
`top`, at each stage choosing the last child, the splits will cover
each dimension once. (Depending on whether `p` divides `n` evenly,
some of the dimensions may be fictive.)  All nodes generated by splits
between the top and bottom of the chain are considered to be part of
the chain. For every node in the chain, its position satifies `x[i] âˆˆ
{b[i], y[i]}` for a base point `b = position(top)` and "opposite
point" `y` which is the position of the final node in the chain.

`success` is true if `box` is a member of a chain. For a general CSp
tree, success is not guaranteed. However, if you only grow the tree
via [`addpoint!`](@ref), all nodes are members of one or more chains
and success is guaranteed.
"""
function chaintop(box::Box{p}) where p
    function process_split!(covered, nremaining, split)
        n = length(covered)
        nnovel = ntarget = p  # how many novel dimensions we're looking for
        for d in split.dims
            nnovel -= d > n || covered[d]
            ntarget -= d > n  # don't count fictive dimensions against the total
        end
        nnovel == ntarget || nnovel == nremaining || return false, nremaining
        # All of the dimensions in this split are novel, so we accept
        # the split and signal that we should keep going
        for d in split.dims
            d <= n || continue
            covered[d] = true
        end
        nremaining -= nnovel
        return true, nremaining
    end

    n = ndims(box)
    covered = falses(n)   # covered[d] signals whether dimension d has appeared
    nremaining = n        # number of dimensions that we haven't yet seen
    bottom = top = box
    # First, go down
    split = box.parent.split
    while nremaining > 0
        didsplit, nremaining = process_split!(covered, nremaining, split)
        didsplit || break
        bottom = split.others.children[end]
        isleaf(bottom) && break
        # If the tree was grown via `addpoint!`, ends of chains may be
        # marked by fictive dimensions. So look for those.
        hasfictive = false
        for d in split.dims
            if d > n
                hasfictive = true
            end
        end
        hasfictive && break
        split = bottom.split
    end
    top = box.parent
    nremaining == 0 && return top, true  # box was already at the top
    isroot(box) && return box, false  # didn't find enough, but we can't go up
    # Go up until all are covered or we encounter a conflict
    split = top.parent.split
    while nremaining > 0
        didsplit, nremaining = process_split!(covered, nremaining, split)
        didsplit || nremaining > 0 || break
        isroot(top) && return top, false
        top = top.parent
        split = top.parent.split
    end
    while nremaining > 0
        # We encountered a conflict before finishing all the
        # dimensions.  For a tree grown with `addpoint!`, this
        # indicates nodes currently between bottom and top are split
        # between two chains. (Since we look for fictive dimensions
        # and those are always at the end of a chain, this can only
        # happen in cases where p divides n evenly.)

        # To solve the problem, backtrack one level at a time until we
        # can complete the chain at the top.
        split = bottom.parent.split
        for d in split.dims
            covered[d] = false
        end
        nremaining += p
        split = top.parent.split
        didsplit, nremaining = process_split!(covered, nremaining, split)
        didsplit || nremaining > 0 || break
        isroot(top) && return top, false
        bottom = bottom.parent
        top = top.parent
    end
    return top, nremaining == 0
end

"""
    Cp = coefficients_p(box)

When fitting a polynomial of degree `p = degree(box)` to the data
around `box`, compute those highest-order coefficients that can be
inferred directly via the `O(1)`-per-split algorithm. This computes
elements of `Cp` that correspond to splits present in `box`'s tree.
Any coefficients that can't be determined via the `O(1)` algorithm are
filled with NaN.

For a CS2 tree, `Cp` will store the off-diagonal elements of the
Hessian. The diagonals (and any undetermined off-diagonals) will be
NaN.
"""
function coefficients_p(f::Function, box::Box{p,T}) where {p,T}
    function bitsum(i)
        s = Int(i & 0x01)
        while i != 0
            i = i >> 1
            s += i & 0x01
        end
        return s
    end
    bitsign(i) = isodd(bitsum(i)) ? -1 : 1
    n = ndims(box)
    Cp = allocate_coefficients_p(n, box)
    # Calculate the number of coefficients that could be set (n choose p)
    nremaining = n
    for i = 1:p-1
        nremaining *= (n-i)/(i+1)
    end
    # Iterate until we fill all coefficients or exhaust the tree
    for split in splits(box)
        dims = split.dims
        maximum(dims) > n && continue
        if isnan(Cp[dims...])
            denom = oneunit(T)
            for (d, x) in zip(split.dims, split.xs)
                denom *= x - position(split.self, d)
            end
            s = isodd(p) ? -1 : 1
            num = zero(T)
            for ichild = 0:maxchildren(box)-1
                num += (s * bitsign(ichild)) * f(getchild(split, ichild))
            end
            Cp[dims...] = num/denom
            nremaining -= 1
        end
        nremaining <= 0 && break
    end
    return Cp
end
coefficients_p(box::Box{p,T}) where {p,T} = coefficients_p(value, box)

allocate_coefficients_p(n, box::Box{p,T}) where {p,T} =
    SymmetricArray(fill(T(NaN), ntuple(d->n, Val(p))))


## SymmetricArray

# A "utility type" (not really core to this package) to make it easy
# to work with higher-order polynomial models.
struct SymmetricArray{T,N,A<:AbstractArray{T,N}} <: AbstractArray{T,N}
    data::A
end
SymmetricArray(A::AbstractArray{T,N}) where {T,N} =
    SymmetricArray{T,N,typeof(A)}(A)

Base.size(S::SymmetricArray) = size(S.data)

function Base.getindex(S::SymmetricArray{T,N}, I::Vararg{Int,N}) where {T,N}
    J = CoordinateSplittingPTrees.tuplesort(I)
    return S.data[J...]
end

function Base.setindex!(S::SymmetricArray{T,N}, val, I::Vararg{Int,N}) where {T,N}
    J = tuplesort(I)
    S.data[J...] = val
    return val
end

tuplesort(dims::Tuple{})        = dims
tuplesort(dims::Tuple{Int})     = dims
tuplesort(dims::Tuple{Int,Int}) = dims[1] > dims[2] ? (dims[2], dims[1]) : dims
tuplesort(dims::NTuple{N,Int}) where N = (sort([dims...])...,)
