### General utilities

"""
    top, success = chaintop(box)

Return a Box `top` that lies at the top of a chain containing
`box`. If we let `n = ndims(box)` and `p = degree(box)`, a chain has
the property that if one follows `ceil(Int, n/p)` splits downward from
`top`, at each stage choosing the last child, the splits will cover
each dimension once. (Depending on whether `p` divides `n` evenly,
some of the dimensions may be fictive.)  All nodes generated by splits
between the top and bottom of the chain are considered to be part of
the chain. For every node in the chain, its position satifies `x[i] âˆˆ
{b[i], y[i]}` for a base point `b = position(top)` and "opposite
point" `y` which is the position of the final node in the chain.

`success` is true if `box` is a member of a chain. For a general CSp
tree, success is not guaranteed. However, if you only grow the tree
via [`addpoint!`](@ref), all nodes are members of one or more chains
and success is guaranteed.
"""
function chaintop(box::Box{p}) where p
    function process_split!(covered, nremaining, split)
        n = length(covered)
        nnovel = ntarget = p  # how many novel dimensions we're looking for
        for d in split.dims
            nnovel -= d > n || covered[d]
            ntarget -= d > n  # don't count fictive dimensions against the total
        end
        nnovel == ntarget || nnovel == nremaining || return false, nremaining
        # All of the dimensions in this split are novel, so we accept
        # the split and signal that we should keep going
        for d in split.dims
            d <= n || continue
            covered[d] = true
        end
        nremaining -= nnovel
        return true, nremaining
    end

    n = ndims(box)
    covered = falses(n)   # covered[d] signals whether dimension d has appeared
    nremaining = n        # number of dimensions that we haven't yet seen
    bottom = top = box
    # First, go down
    split = box.parent.split
    while nremaining > 0
        didsplit, nremaining = process_split!(covered, nremaining, split)
        didsplit || break
        bottom = split.others.children[end]
        isleaf(bottom) && break
        # If the tree was grown via `addpoint!`, ends of chains may be
        # marked by fictive dimensions. So look for those.
        hasfictive = false
        for d in split.dims
            if d > n
                hasfictive = true
            end
        end
        hasfictive && break
        split = bottom.split
    end
    top = box.parent
    nremaining == 0 && return top, true  # box was already at the top
    isroot(box) && return box, false  # didn't find enough, but we can't go up
    # Go up until all are covered or we encounter a conflict
    split = top.parent.split
    while nremaining > 0
        didsplit, nremaining = process_split!(covered, nremaining, split)
        didsplit || nremaining > 0 || break
        isroot(top) && return top, false
        top = top.parent
        split = top.parent.split
    end
    while nremaining > 0
        # We encountered a conflict before finishing all the
        # dimensions.  For a tree grown with `addpoint!`, this
        # indicates nodes currently between bottom and top are split
        # between two chains. (Since we look for fictive dimensions
        # and those are always at the end of a chain, this can only
        # happen in cases where p divides n evenly.)

        # To solve the problem, backtrack one level at a time until we
        # can complete the chain at the top.
        split = bottom.parent.split
        for d in split.dims
            covered[d] = false
        end
        nremaining += p
        split = top.parent.split
        didsplit, nremaining = process_split!(covered, nremaining, split)
        didsplit || nremaining > 0 || break
        isroot(top) && return top, false
        bottom = bottom.parent
        top = top.parent
    end
    return top, nremaining == 0
end
